<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>General complex eigenproblems &#8212; ezARPACK 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b76e3c8a" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css?v=0885a68f" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=359c27e9"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script async="async" src="/ezARPACK/mathjax/MathJax.js?config=default"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Parallel ARPACK versions of eigensolvers" href="mpi.html" />
    <link rel="prev" title="General real eigenproblems" href="asymmetric.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="mpi.html" title="Parallel ARPACK versions of eigensolvers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="asymmetric.html" title="General real eigenproblems"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">ezARPACK 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">User guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">General complex eigenproblems</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="general-complex-eigenproblems">
<span id="complex"></span><h1>General complex eigenproblems<a class="headerlink" href="#general-complex-eigenproblems" title="Permalink to this heading">¶</a></h1>
<p>This page is a walkthrough showing how to use
<a class="reference internal" href="../reference/solver_complex.html#refsolvercomplex"><span class="std std-ref">ezarpack::arpack_solver&lt;Complex, Backend&gt;</span></a> in
your C++ code to compute a few eigenpairs <span class="math notranslate nohighlight">\((\lambda,\mathbf{x})\)</span> of</p>
<div class="math notranslate nohighlight">
\[\hat A  \mathbf{x} = \lambda \hat M \mathbf{x}\]</div>
<p>with a complex matrix <span class="math notranslate nohighlight">\(\hat A\)</span> and a complex Hermitian positive
semi-definite matrix <span class="math notranslate nohighlight">\(\hat M\)</span>. The complex solver class supports a few
computational modes, where the original eigenproblem is recast into</p>
<div class="math notranslate nohighlight">
\[\hat O \mathbf{x} = \mu \mathbf{x}.\]</div>
<p>Operator <span class="math notranslate nohighlight">\(\hat O\)</span> acts in a vector space equipped with an inner product
defined by the matrix <span class="math notranslate nohighlight">\(\hat B = \hat M\)</span>,</p>
<div class="math notranslate nohighlight">
\[\langle \mathbf{x}, \mathbf{y} \rangle = \mathbf{x}^\dagger \hat B \mathbf{y}.\]</div>
<p>There are explicit relations between the original eigenvalues <span class="math notranslate nohighlight">\(\lambda\)</span>
and their transformed counterparts <span class="math notranslate nohighlight">\(\mu\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If both matrices <span class="math notranslate nohighlight">\(\hat A\)</span> and <span class="math notranslate nohighlight">\(\hat M\)</span> are real,
<a class="reference internal" href="../reference/solver_symmetric.html#refsolversymmetric"><span class="std std-ref">ezarpack::arpack_solver&lt;Symmetric, Backend&gt;</span></a> or
<a class="reference internal" href="../reference/solver_asymmetric.html#refsolverasymmetric"><span class="std std-ref">ezarpack::arpack_solver&lt;Asymmetric, Backend&gt;</span></a>
should be used instead.</p>
</div>
<p>Typical steps needed to compute the eigenpairs are as follows.</p>
<ol class="arabic simple">
<li><p>Decide what <a class="reference internal" href="backends.html#backends"><span class="std std-ref">storage backend</span></a> you want to use or whether it is
appropriate to <a class="reference internal" href="new_backend.html#new-backend"><span class="std std-ref">implement a new one</span></a>. In the following, we
will assume that the <a class="reference external" href="http://eigen.tuxfamily.org">Eigen</a> backend has been
selected.</p></li>
<li><p>Include <code class="docutils literal notranslate"><span class="pre">&lt;ezarpack/arpack_solver.hpp&gt;</span></code> and the relevant backend header.</p></li>
</ol>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;ezarpack/arpack_solver.hpp&gt;</span>
<span class="c1">#include &lt;ezarpack/storages/eigen.hpp&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;ezarpack/arpack_solver.hpp&gt;</span></code> includes
<a class="reference internal" href="../reference/arpack_solver.html#refsolver"><span class="std std-ref">all three specializations of ezarpack::arpack_solver</span></a>
at once. If you want to speed up compilation a little bit, you can
include <code class="docutils literal notranslate"><span class="pre">&lt;ezarpack/solver_base.hpp&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">&lt;ezarpack/solver_complex.hpp&gt;</span></code> instead.</p>
</div>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>Create a solver object.</p></li>
</ol>
<blockquote>
<div><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="c1">// Size of matrices A and M</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">ezarpack</span><span class="p">;</span>

<span class="c1">// Shorthand for solver&#39;s type.</span>
<span class="k">using</span><span class="w"> </span><span class="n">solver_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arpack_solver</span><span class="o">&lt;</span><span class="n">Complex</span><span class="p">,</span><span class="w"> </span><span class="n">eigen_storage</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// Solver object.</span>
<span class="n">solver_t</span><span class="w"> </span><span class="nf">solver</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>Fill a <code class="docutils literal notranslate"><span class="pre">params_t</span></code> structure with calculation parameters.</p></li>
</ol>
<blockquote>
<div><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// params_t is a structure holding parameters of</span>
<span class="c1">// the Implicitly Restarted Arnoldi iteration.</span>
<span class="k">using</span><span class="w"> </span><span class="n">params_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver_t</span><span class="o">::</span><span class="n">params_t</span><span class="p">;</span>

<span class="c1">// Requested number of eigenvalues to compute.</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="c1">// Compute the eigenvalues with the largest magnitudes.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">eigenvalues_select</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params_t</span><span class="o">::</span><span class="n">LargestMagnitude</span><span class="p">;</span>

<span class="c1">// Compute Ritz vectors (eigenvectors).</span>
<span class="n">params_t</span><span class="o">::</span><span class="n">compute_vectors_t</span><span class="w"> </span><span class="n">compute_vectors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params_t</span><span class="o">::</span><span class="n">Ritz</span><span class="p">;</span>

<span class="c1">// params_t&#39;s constructor takes three arguments -- mandatory parameters</span>
<span class="c1">// that need be set explicitly.</span>
<span class="n">params_t</span><span class="w"> </span><span class="nf">params</span><span class="p">(</span><span class="n">nev</span><span class="p">,</span><span class="w"> </span><span class="n">eigenvalues_select</span><span class="p">,</span><span class="w"> </span><span class="n">compute_vectors</span><span class="p">);</span>
</pre></div>
</div>
<p>The following table contains an annotated list of all supported parameters.</p>
<table class="docutils align-left" id="params">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default value</p></th>
<th class="head"><p>Description</p>
</th>
</tr>
</thead>
<tbody id="complex-n-eigenvalues">
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">n_eigenvalues</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code></p></td>
<td><p>n/a</p></td>
<td><p>Number of eigenvalues to compute.</p>
</td>
</tr>
<tr class="row-odd" id="complex-eigenvalues-select"><td><p><code class="docutils literal notranslate"><span class="pre">eigenvalues_select</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">params_t::eigenvalues_select_t</span></code> (enumeration)</p></td>
<td><p>n/a</p></td>
<td><p>Part of the spectrum to target. Acceptable values are
<code class="docutils literal notranslate"><span class="pre">LargestMagnitude</span></code> (largest eigenvalues in magnitude),
<code class="docutils literal notranslate"><span class="pre">SmallestMagnitude</span></code> (smallest eigenvalues in magnitude),
<code class="docutils literal notranslate"><span class="pre">LargestReal</span></code> (eigenvalues of largest real part),
<code class="docutils literal notranslate"><span class="pre">SmallestReal</span></code> (eigenvalues of smallest real part),
<code class="docutils literal notranslate"><span class="pre">LargestImag</span></code> (eigenvalues of largest imaginary part) and
<code class="docutils literal notranslate"><span class="pre">SmallestImag</span></code> (eigenvalues of smallest imaginary part).</p>
</td>
</tr>
<tr class="row-even" id="complex-ncv"><td><p><code class="docutils literal notranslate"><span class="pre">ncv</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>min(2 * <code class="docutils literal notranslate"><span class="pre">n_eigenvalues</span></code> + 2, <code class="docutils literal notranslate"><span class="pre">N</span></code>)</p></td>
<td><p>How many Arnoldi vectors to generate at each iteration.</p>
</td>
</tr>
<tr class="row-odd" id="complex-compute-vectors"><td><p><code class="docutils literal notranslate"><span class="pre">compute_vectors</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">compute_vectors_t</span></code> (enumeration)</p></td>
<td><p>n/a</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Schur</span></code> – compute only Schur vectors (orthogonal basis vectors of
the <code class="docutils literal notranslate"><span class="pre">n_eigenvalues</span></code>-dimensional subspace), <code class="docutils literal notranslate"><span class="pre">Ritz</span></code> – compute Ritz
vectors (eigenvectors) in addition to the Schur vectors, <code class="docutils literal notranslate"><span class="pre">None</span></code> –
compute neither Schur nor Ritz vectors.</p>
</td>
</tr>
<tr class="row-even" id="complex-random-residual-vector"><td><p><code class="docutils literal notranslate"><span class="pre">random_residual_vector</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">true</span></code></p></td>
<td><p>Use a randomly generated initial residual vector?</p>
</td>
</tr>
<tr class="row-odd" id="complex-sigma"><td><p><code class="docutils literal notranslate"><span class="pre">sigma</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">std::complex&lt;double&gt;</span></code></p></td>
<td><p><cite>0</cite></p></td>
<td><p>Complex eigenvalue shift <span class="math notranslate nohighlight">\(\sigma\)</span> for spectral transformation
modes.</p>
</td>
</tr>
<tr class="row-even" id="complex-tolerance"><td><p><code class="docutils literal notranslate"><span class="pre">tolerance</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">double</span></code></p></td>
<td><p>Machine precision</p></td>
<td><p>Relative tolerance for Ritz value (eigenvalue) convergence.</p>
</td>
</tr>
<tr class="row-odd" id="complex-max-iter"><td><p><code class="docutils literal notranslate"><span class="pre">max_iter</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code></p></td>
<td><p>Maximum number of Arnoldi update iterations allowed.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the Shift-and-Invert mode, values of
<a class="reference internal" href="#complex-eigenvalues-select"><span class="std std-ref">eigenvalues_select</span></a> refer
to the spectrum of the <strong>transformed</strong> problem, not the original one. For
instance, <code class="docutils literal notranslate"><span class="pre">LargestMagnitude</span></code> with a complex shift <span class="math notranslate nohighlight">\(\sigma\)</span>
will pick eigenvalues <span class="math notranslate nohighlight">\(\lambda\)</span> closest to
<span class="math notranslate nohighlight">\(\sigma\)</span>, because they correspond to the eigenvalues
<span class="math notranslate nohighlight">\(\mu = 1/(\lambda - \sigma)\)</span> that have the largest magnitude.</p>
</div>
</div></blockquote>
<ol class="arabic" start="5">
<li><p>Optionally set the initial vector for Arnoldi iteration if a better choice
than a random vector is known.
<a class="reference internal" href="#complex-random-residual-vector"><span class="std std-ref">random_residual_vector</span></a> parameter must
be set to <code class="docutils literal notranslate"><span class="pre">false</span></code> for the changes made to the initial vector
to take effect.</p>
<p>A view of the residual vector is accessible via method
<code class="docutils literal notranslate"><span class="pre">residual_vector()</span></code> of the solver.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Set all components of the initial vector to 1.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">rv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">residual_vector</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">rv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
</pre></div>
</div>
<p>One may also call <code class="docutils literal notranslate"><span class="pre">residual_vector()</span></code> later, after a diagonalization run
has started, to retrieve the current residual vector.</p>
</li>
<li><p>Choose one of supported computational modes and perform diagonalization.
In this part, user is supposed to call the <code class="docutils literal notranslate"><span class="pre">solver</span></code> object and pass the
parameter structure as well as callable objects (<em>e.g.</em> lambda-functions)
that represent action of operators <span class="math notranslate nohighlight">\(\hat O\)</span> and <span class="math notranslate nohighlight">\(\hat B\)</span> on
a given vector. The supplied objects will be called to generate Arnoldi
vectors. Syntax and semantics of the C++ code vary between
the computational modes and will be explained individually for each of
them.</p>
<blockquote>
<div></div></blockquote>
<ul id="complex-standard">
<li><p><strong>Standard mode</strong> (for standard eigenproblems, <span class="math notranslate nohighlight">\(\hat M = \hat I\)</span>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">vector_view_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver_t</span><span class="o">::</span><span class="n">vector_view_t</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">vector_const_view_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver_t</span><span class="o">::</span><span class="n">vector_const_view_t</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">Aop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">vector_const_view_t</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">vector_view_t</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Code implementing action of matrix A on vector &#39;in&#39;:</span>
<span class="w">  </span><span class="c1">// out = A * in</span>
<span class="p">};</span>

<span class="n">solver</span><span class="p">(</span><span class="n">Aop</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li id="complex-inverse"><p><strong>Regular inverse mode</strong> (for positive-definite <span class="math notranslate nohighlight">\(\hat M\)</span>).</p>
<p>In this mode, the transformed eigenproblem is defined by
<span class="math notranslate nohighlight">\(\hat O = \hat M^{-1} \hat A\)</span>, <span class="math notranslate nohighlight">\(\hat B = \hat M\)</span> and
<span class="math notranslate nohighlight">\(\lambda = \mu\)</span>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">vector_view_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver_t</span><span class="o">::</span><span class="n">vector_view_t</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">vector_const_view_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver_t</span><span class="o">::</span><span class="n">vector_const_view_t</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">vector_const_view_t</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">vector_view_t</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Code implementing action of matrix M^{-1} A on vector &#39;in&#39;:</span>
<span class="w">  </span><span class="c1">// out = M^{-1} * A * in</span>
<span class="p">};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">Bop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">vector_const_view_t</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">vector_view_t</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Code implementing action of matrix M on vector &#39;in&#39;:</span>
<span class="w">  </span><span class="c1">// out = M * in</span>
<span class="p">};</span>

<span class="n">solver</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">Bop</span><span class="p">,</span><span class="w"> </span><span class="n">solver_t</span><span class="o">::</span><span class="n">Inverse</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>Inverting a sparse matrix <span class="math notranslate nohighlight">\(\hat M\)</span> will likely make it dense, which
is usually undesirable from the storage standpoint. A more practical
solution is to compute the sparse LU or Cholesky factorization of
<span class="math notranslate nohighlight">\(\hat M\)</span> once (outside of the lambda-function’s body), and write
the lambda-function so that it computes <code class="docutils literal notranslate"><span class="pre">out</span></code> as the solution of
the linear system <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">*</span> <span class="pre">out</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">in</span></code> using the precomputed factorization.</p>
</li>
<li id="complex-shiftandinvert"><p><strong>Shift-and-Invert mode</strong>.</p>
<p>In this mode, the transformed eigenproblem is defined by
<span class="math notranslate nohighlight">\(\hat O = (\hat A -\sigma \hat M)^{-1} \hat M\)</span>,
<span class="math notranslate nohighlight">\(\hat B = \hat M\)</span> and <span class="math notranslate nohighlight">\(\lambda = 1/\mu + \sigma\)</span>.
The complex spectral shift <span class="math notranslate nohighlight">\(\sigma\)</span> must be set in the parameters
structure, see the <a class="reference internal" href="#complex-sigma"><span class="std std-ref">list of parameters</span></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">vector_view_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver_t</span><span class="o">::</span><span class="n">vector_view_t</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">vector_const_view_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver_t</span><span class="o">::</span><span class="n">vector_const_view_t</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">vector_view_t</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">vector_view_t</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Code implementing action of matrix (A - sigma*M)^{-1} * M on &#39;in&#39;:</span>
<span class="w">  </span><span class="c1">// out = (A - sigma*M)^{-1} * M * in</span>
<span class="p">};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">Bop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">vector_const_view_t</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">vector_view_t</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Code implementing action of matrix M on vector &#39;in&#39;:</span>
<span class="w">  </span><span class="c1">// out = M * in</span>
<span class="p">};</span>

<span class="n">solver</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">Bop</span><span class="p">,</span><span class="w"> </span><span class="n">solver_t</span><span class="o">::</span><span class="n">ShiftAndInvert</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>Inverting a sparse matrix <span class="math notranslate nohighlight">\(\hat A - \sigma\hat M\)</span> will likely make it
dense, which is usually undesirable from the storage standpoint. A more
practical solution is to compute the sparse LU or Cholesky factorization of
<span class="math notranslate nohighlight">\(\hat A - \sigma\hat M\)</span> once (outside of the lambda-function’s body),
and write the lambda-function so that it (1) computes <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">*</span> <span class="pre">in</span></code> and
(2) computes <code class="docutils literal notranslate"><span class="pre">out</span></code> as the solution of the linear system
<code class="docutils literal notranslate"><span class="pre">(A</span> <span class="pre">-</span> <span class="pre">\sigma</span> <span class="pre">M)</span> <span class="pre">*</span> <span class="pre">out</span> <span class="pre">=</span> <span class="pre">M</span> <span class="pre">*</span> <span class="pre">in</span></code> using the precomputed factorization.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In most computational modes above, it is seemingly necessary to apply
operator <span class="math notranslate nohighlight">\(\hat B\)</span> to the same vector twice per generated Arnoldi
vector, once in functor <code class="docutils literal notranslate"><span class="pre">op</span></code> and once in <code class="docutils literal notranslate"><span class="pre">Bop</span></code>. It is actually possible
to spare one of the applications. Calling <code class="docutils literal notranslate"><span class="pre">solver.Bx_available()</span></code> inside
<code class="docutils literal notranslate"><span class="pre">op</span></code> will tell whether <code class="docutils literal notranslate"><span class="pre">Bop</span></code> has already been called at the current
iteration, and <code class="docutils literal notranslate"><span class="pre">solver.Bx_vector()</span></code> will return a constant view of the
application result <span class="math notranslate nohighlight">\(\hat B \mathbf{x}\)</span>.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">out</span></code> views passed to the callable objects always expose one
of three length-<span class="math notranslate nohighlight">\(N\)</span> vectors stored inside the solver object. There is
another, indirect way to access them.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get index (0-2) of the current &#39;in&#39; vector and request a view of it</span>
<span class="k">auto</span><span class="w"> </span><span class="n">in_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">workspace_vector</span><span class="p">(</span><span class="n">solver</span><span class="p">.</span><span class="n">in_vector_n</span><span class="p">());</span>
<span class="c1">// Similar for the &#39;out&#39; vector</span>
<span class="k">auto</span><span class="w"> </span><span class="n">out_view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">workspace_vector</span><span class="p">(</span><span class="n">solver</span><span class="p">.</span><span class="n">out_vector_n</span><span class="p">());</span>
</pre></div>
</div>
<p>In advanced usage scenarios, the implicit restarting procedure can be
customized via an extra argument of <code class="docutils literal notranslate"><span class="pre">solver</span></code>’s call operator.
See ‘<a class="reference internal" href="implicit_restarting.html#restarting"><span class="std std-ref">Advanced: Customization of Lanczos/Arnoldi implicit restarting</span></a>’ for more details.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">shifts_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">solver_t</span><span class="o">::</span><span class="n">complex_vector_const_view_t</span><span class="w"> </span><span class="n">ritz_values</span><span class="p">,</span>
<span class="w">                   </span><span class="n">solver_t</span><span class="o">::</span><span class="n">complex_vector_const_view_t</span><span class="w"> </span><span class="n">ritz_bounds</span><span class="p">,</span>
<span class="w">                   </span><span class="n">solver_t</span><span class="o">::</span><span class="n">complex_vector_view_t</span><span class="w"> </span><span class="n">shifts</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                     </span><span class="c1">// Compute shifts for the implicit restarting</span>
<span class="w">                   </span><span class="p">};</span>

<span class="c1">// Standard mode</span>
<span class="n">solver</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="n">shifts_f</span><span class="p">);</span>
<span class="c1">// Other modes, e.g. Inverse</span>
<span class="n">solver</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">Bop</span><span class="p">,</span><span class="w"> </span><span class="n">solver_t</span><span class="o">::</span><span class="n">Inverse</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="n">shifts_f</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">solver_t::operator()</span></code> can throw two special exception types.</p>
<ul class="simple">
<li><p><a class="reference internal" href="../reference/common.html#_CPPv4N8ezarpack15maxiter_reachedE" title="ezarpack::maxiter_reached"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">ezarpack::maxiter_reached</span></code></a> - Maximum number of
implicitly restarted Arnoldi iterations has been reached.</p></li>
<li><p><a class="reference internal" href="../reference/common.html#_CPPv4N8ezarpack16ncv_insufficientE" title="ezarpack::ncv_insufficient"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">ezarpack::ncv_insufficient</span></code></a> - No shifts could be
applied during a cycle of the Implicitly restarted Arnoldi iteration.
Consider increasing the number of Arnoldi vectors generated at each
iteration (<a class="reference internal" href="#complex-ncv"><span class="std std-ref">ncv</span></a> parameter).</p></li>
</ul>
<p>The rest of possible problems reported by ARPACK-NG result in generic
<a class="reference external" href="https://en.cppreference.com/w/cpp/error/runtime_error">std::runtime_error</a>
exceptions.</p>
<p>7. Request computed eigenvalues and eigenvectors. For the eigenvectors, the
<a class="reference internal" href="#complex-compute-vectors"><span class="std std-ref">compute_vectors</span></a> parameter must be set to
<code class="docutils literal notranslate"><span class="pre">params_t::Ritz</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">eigenvalues</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">vecs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">eigenvectors</span><span class="p">();</span>
</pre></div>
</div>
<p>The eigenvectors are columns of the complex matrix view <code class="docutils literal notranslate"><span class="pre">vecs</span></code>.
If the diagonalization run has ended prematurely (for example, when
the maximum number of iterations has been reached), then it is still
possible to extract <code class="docutils literal notranslate"><span class="pre">solver.nconv()</span></code> converged eigenpairs.</p>
</li>
</ol>
<ol class="arabic" start="8">
<li><p>Optionally request the Schur vectors, i.e. <span class="math notranslate nohighlight">\(\hat B\)</span>-orthogonal basis
vectors of the relevant vector subspace
(<a class="reference internal" href="#complex-compute-vectors"><span class="std std-ref">compute_vectors</span></a> must be either
<code class="docutils literal notranslate"><span class="pre">params_t::Schur</span></code> or <code class="docutils literal notranslate"><span class="pre">params_t::Ritz</span></code>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">basis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">schur_vectors</span><span class="p">();</span>
</pre></div>
</div>
<p>The basis vectors are <code class="docutils literal notranslate"><span class="pre">solver.nconv()</span></code> columns of the complex matrix
view <code class="docutils literal notranslate"><span class="pre">basis</span></code>.</p>
</li>
<li><p>Optionally request statistics about the completed run.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Print some computation statistics</span>
<span class="k">auto</span><span class="w"> </span><span class="n">stats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">stats</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Number of Arnoldi update iterations: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">stats</span><span class="p">.</span><span class="n">n_iter</span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Total number of O*x operations: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">stats</span><span class="p">.</span><span class="n">n_op_x_operations</span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Total number of B*x operations: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">stats</span><span class="p">.</span><span class="n">n_b_x_operations</span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Total number of steps of re-orthogonalization: &quot;</span>
<span class="w">          </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">stats</span><span class="p">.</span><span class="n">n_reorth_steps</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ol>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation instructions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">User guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="usage.html">How to use ezARPACK in your project</a></li>
<li class="toctree-l2"><a class="reference internal" href="choice.html">What algorithm variant is right for your problem?</a></li>
<li class="toctree-l2"><a class="reference internal" href="symmetric.html">Symmetric real eigenproblems</a></li>
<li class="toctree-l2"><a class="reference internal" href="asymmetric.html">General real eigenproblems</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">General complex eigenproblems</a></li>
<li class="toctree-l2"><a class="reference internal" href="mpi.html">Parallel ARPACK versions of eigensolvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="backends.html">List of supported matrix/vector algebra libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="implicit_restarting.html">Advanced: Customization of Lanczos/Arnoldi implicit restarting</a></li>
<li class="toctree-l2"><a class="reference internal" href="new_backend.html">Advanced: Adding a new storage backend</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html">Usage examples: serial solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples_mpi.html">Usage examples: MPI-parallelized solvers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../search.html">Search Page</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/guide/complex.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="mpi.html" title="Parallel ARPACK versions of eigensolvers"
             >next</a> |</li>
        <li class="right" >
          <a href="asymmetric.html" title="General real eigenproblems"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">ezARPACK 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >User guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">General complex eigenproblems</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2016-2023, Igor Krivenko.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.1.1.
    </div>
  </body>
</html>