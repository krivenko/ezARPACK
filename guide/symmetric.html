
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Symmetric real eigenproblems &#8212; ezARPACK 0.9 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="/ezARPACK/mathjax/MathJax.js?config=default"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="General real eigenproblems" href="asymmetric.html" />
    <link rel="prev" title="What algorithm variant is right for your problem?" href="choice.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="asymmetric.html" title="General real eigenproblems"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="choice.html" title="What algorithm variant is right for your problem?"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">ezARPACK 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">User guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Symmetric real eigenproblems</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="symmetric-real-eigenproblems">
<span id="symmetric"></span><h1>Symmetric real eigenproblems<a class="headerlink" href="#symmetric-real-eigenproblems" title="Permalink to this headline">Â¶</a></h1>
<p>This page is a walkthrough showing how to use
<a class="reference internal" href="../reference/solver_symmetric.html#refsolversymmetric"><span class="std std-ref">ezarpack::arpack_solver&lt;Symmetric, Backend&gt;</span></a> in
your C++ code to compute a few eigenpairs <span class="math notranslate nohighlight">\((\lambda,\mathbf{x})\)</span> of</p>
<div class="math notranslate nohighlight">
\[\hat A  \mathbf{x} = \lambda \hat M \mathbf{x}\]</div>
<p>with real symmetric matrices <span class="math notranslate nohighlight">\(\hat A\)</span> and <span class="math notranslate nohighlight">\(\hat M\)</span>. The symmetric
solver class supports a few computational modes, where the original eigenproblem
is recast into</p>
<div class="math notranslate nohighlight">
\[\hat O \mathbf{x} = \mu \mathbf{x}.\]</div>
<p>The new matrix <span class="math notranslate nohighlight">\(\hat O\)</span> is symmetric w.r.t. to an inner product
defined by a symmetric positive semi-definite matrix <span class="math notranslate nohighlight">\(\hat B\)</span>,</p>
<div class="math notranslate nohighlight">
\[\langle \mathbf{x}, \hat O \mathbf{y} \rangle =
\langle \hat O \mathbf{x}, \mathbf{y} \rangle, \quad
\langle \mathbf{x}, \mathbf{y} \rangle = \mathbf{x}^T \hat B \mathbf{y}\]</div>
<p>or, equivalently,</p>
<div class="math notranslate nohighlight">
\[\hat B \hat O = \hat O^T \hat B.\]</div>
<p>There are explicit relations between the original eigenvalues <span class="math notranslate nohighlight">\(\lambda\)</span>
and their transformed counterparts <span class="math notranslate nohighlight">\(\mu\)</span>. <span class="math notranslate nohighlight">\(\lambda\)</span> are guaranteed
to be real, and computed eigenvectors <span class="math notranslate nohighlight">\(\mathbf{x}_i\)</span> form an
orthonormal system w.r.t. the <span class="math notranslate nohighlight">\(\hat B\)</span>-weighted inner product,
<span class="math notranslate nohighlight">\(\langle \mathbf{x}_i, \mathbf{x}_j \rangle = \delta_{i,j}\)</span>.</p>
<p>Typical steps needed to compute the eigenpairs are as follows.</p>
<ol class="arabic simple">
<li><p>Decide what <a class="reference internal" href="backends.html#backends"><span class="std std-ref">storage backend</span></a> you want to use or whether it is
appropriate to <a class="reference internal" href="new_backend.html#new-backend"><span class="std std-ref">implement a new one</span></a>. In the following, we
will assume that the <a class="reference external" href="http://eigen.tuxfamily.org">Eigen</a> backend has been
selected.</p></li>
<li><p>Include <code class="docutils literal notranslate"><span class="pre">&lt;ezarpack/arpack_solver.hpp&gt;</span></code> and the relevant backend header.</p></li>
</ol>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;ezarpack/arpack_solver.hpp&gt;</span>
<span class="c1">#include &lt;ezarpack/storages/eigen.hpp&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;ezarpack/arpack_solver.hpp&gt;</span></code> includes
<a class="reference internal" href="../reference/arpack_solver.html#refsolver"><span class="std std-ref">all three specializations of ezarpack::arpack_solver</span></a>
at once. If you want to speed up compilation a little bit, you can
include <code class="docutils literal notranslate"><span class="pre">&lt;ezarpack/solver_base.hpp&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">&lt;ezarpack/solver_symmetric.hpp&gt;</span></code> instead.</p>
</div>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>Create a solver object.</p></li>
</ol>
<blockquote>
<div><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// Size of matrices A and M</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">ezarpack</span><span class="p">;</span>

<span class="c1">// Shorthand for solver&#39;s type.</span>
<span class="k">using</span> <span class="n">solver_t</span> <span class="o">=</span> <span class="n">arpack_solver</span><span class="o">&lt;</span><span class="n">Symmetric</span><span class="p">,</span> <span class="n">eigen_storage</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// Solver object.</span>
<span class="n">solver_t</span> <span class="nf">solver</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>Fill a <code class="docutils literal notranslate"><span class="pre">params_t</span></code> structure with calculation parameters.</p></li>
</ol>
<blockquote>
<div><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// params_t is a structure holding parameters of</span>
<span class="c1">// the Implicitly Restarted Lanczos iteration.</span>
<span class="k">using</span> <span class="n">params_t</span> <span class="o">=</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">params_t</span><span class="p">;</span>

<span class="c1">// Requested number of eigenvalues to compute.</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">nev</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="c1">// Compute the smallest eigenvalues.</span>
<span class="k">auto</span> <span class="n">eigenvalues_select</span> <span class="o">=</span> <span class="n">params_t</span><span class="o">::</span><span class="n">Smallest</span><span class="p">;</span>

<span class="c1">// Compute eigenvectors too?</span>
<span class="kt">bool</span> <span class="n">compute_eigenvectors</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="c1">// params_t&#39;s constructor takes three arguments -- mandatory parameters</span>
<span class="c1">// that need be set explicitly.</span>
<span class="n">params_t</span> <span class="nf">params</span><span class="p">(</span><span class="n">nev</span><span class="p">,</span> <span class="n">eigenvalues_select</span><span class="p">,</span> <span class="n">compute_eigenvectors</span><span class="p">);</span>
</pre></div>
</div>
<p>The following table contains an annotated list of all supported parameters.</p>
<table class="colwidths-auto docutils align-left" id="sym-params">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default value</p></th>
<th class="head"><p>Description</p>
</th>
</tr>
</thead>
<tbody id="sym-n-eigenvalues">
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">n_eigenvalues</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code></p></td>
<td><p>n/a</p></td>
<td><p>Number of eigenvalues to compute.</p>
</td>
</tr>
<tr class="row-odd" id="sym-eigenvalues-select"><td><p><code class="docutils literal notranslate"><span class="pre">eigenvalues_select</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">params_t::eigenvalues_select_t</span></code> (enumeration)</p></td>
<td><p>n/a</p></td>
<td><p>Part of the spectrum to target. Acceptable values are
<code class="docutils literal notranslate"><span class="pre">Largest</span></code> (algebraically largest eigenvalues),
<code class="docutils literal notranslate"><span class="pre">Smallest</span></code> (algebraically smallest eigenvalues),
<code class="docutils literal notranslate"><span class="pre">LargestMagnitude</span></code> (largest eigenvalues in magnitude),
<code class="docutils literal notranslate"><span class="pre">SmallestMagnitude</span></code> (smallest eigenvalues in magnitude) and
<code class="docutils literal notranslate"><span class="pre">BothEnds</span></code> (eigenvalues at both ends of the spectrum;
If <code class="docutils literal notranslate"><span class="pre">n_eigenvalues</span></code> is odd, compute one more from the high end
than from the low end).</p>
</td>
</tr>
<tr class="row-even" id="sym-ncv"><td><p><code class="docutils literal notranslate"><span class="pre">ncv</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>min(2 * <code class="docutils literal notranslate"><span class="pre">n_eigenvalues</span></code> + 2, <code class="docutils literal notranslate"><span class="pre">N</span></code>)</p></td>
<td><p>How many Lanczos vectors to generate at each iteration.</p>
</td>
</tr>
<tr class="row-odd" id="sym-compute-eigenvectors"><td><p><code class="docutils literal notranslate"><span class="pre">compute_eigenvectors</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p>n/a</p></td>
<td><p>Request computation of eigenvectors in addition to the eigenvalues.</p>
</td>
</tr>
<tr class="row-even" id="sym-random-residual-vector"><td><p><code class="docutils literal notranslate"><span class="pre">random_residual_vector</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">true</span></code></p></td>
<td><p>Use a randomly generated initial residual vector?</p>
</td>
</tr>
<tr class="row-odd" id="sym-sigma"><td><p><code class="docutils literal notranslate"><span class="pre">sigma</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">double</span></code></p></td>
<td><p><cite>0</cite></p></td>
<td><p>Real eigenvalue shift <span class="math notranslate nohighlight">\(\sigma\)</span> for spectral transformation modes.</p>
</td>
</tr>
<tr class="row-even" id="sym-tolerance"><td><p><code class="docutils literal notranslate"><span class="pre">tolerance</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">double</span></code></p></td>
<td><p>Machine precision</p></td>
<td><p>Relative tolerance for Ritz value (eigenvalue) convergence.</p>
</td>
</tr>
<tr class="row-odd" id="sym-max-iter"><td><p><code class="docutils literal notranslate"><span class="pre">max_iter</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code></p></td>
<td><p>Maximum number of Lanczos update iterations allowed.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the spectral transformation modes, values of
<a class="reference internal" href="#sym-eigenvalues-select"><span class="std std-ref">eigenvalues_select</span></a> refer
to the spectrum of the <strong>transformed</strong> problem, not the original one. For
instance, <code class="docutils literal notranslate"><span class="pre">LargestMagnitude</span></code> used in the shift-and-invert mode will pick
eigenvalues <span class="math notranslate nohighlight">\(\lambda\)</span> closest to the shift <span class="math notranslate nohighlight">\(\sigma\)</span>, because
they correspond to the eigenvalues <span class="math notranslate nohighlight">\(\mu = 1/(\lambda - \sigma)\)</span>
that have the largest magnitude.</p>
</div>
</div></blockquote>
<ol class="arabic" start="5">
<li><p>Optionally set the initial vector for Lanczos iteration if a better choice
than a random vector is known. The
<a class="reference internal" href="#sym-random-residual-vector"><span class="std std-ref">random_residual_vector</span></a> parameter must
be set to <code class="docutils literal notranslate"><span class="pre">false</span></code> for the changes made to the initial vector to take
effect.</p>
<p>A view of the residual vector is accessible via method
<code class="docutils literal notranslate"><span class="pre">residual_vector()</span></code> of the solver.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Set all components of the initial vector to 1.</span>
<span class="k">auto</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">residual_vector</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">rv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</pre></div>
</div>
<p>One may also call <code class="docutils literal notranslate"><span class="pre">residual_vector()</span></code> later, after a diagonalization run
has started, to retrieve the current residual vector.</p>
</li>
<li><p>Choose one of supported computational modes and perform diagonalization.
In this part, user is supposed to call the <code class="docutils literal notranslate"><span class="pre">solver</span></code> object and pass the
parameter structure as well as callable objects (<em>e.g.</em> lambda-functions)
that represent action of operators <span class="math notranslate nohighlight">\(\hat O\)</span> and <span class="math notranslate nohighlight">\(\hat B\)</span> on
a given vector. The supplied objects will be called to generate Lanczos
vectors. Syntax and semantics of the C++ code vary between
the computational modes and will be explained individually for each of
them.</p>
<blockquote>
<div></div></blockquote>
<ul id="sym-standard">
<li><p><strong>Standard mode</strong> (for standard eigenproblems, <span class="math notranslate nohighlight">\(\hat M = \hat I\)</span>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">vector_view_t</span> <span class="o">=</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">vector_view_t</span><span class="p">;</span>
<span class="k">using</span> <span class="n">vector_const_view_t</span> <span class="o">=</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">vector_const_view_t</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">Aop</span> <span class="o">=</span> <span class="p">[](</span><span class="n">vector_const_view_t</span> <span class="n">in</span><span class="p">,</span> <span class="n">vector_view_t</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Code implementing action of matrix A on vector &#39;in&#39;:</span>
  <span class="c1">// out = A * in</span>
<span class="p">};</span>

<span class="n">solver</span><span class="p">(</span><span class="n">Aop</span><span class="p">,</span> <span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li id="sym-inverse"><p><strong>Regular inverse mode</strong> (for symmetric positive-definite <span class="math notranslate nohighlight">\(\hat M\)</span>).</p>
<p>In this mode, the transformed eigenproblem is defined by
<span class="math notranslate nohighlight">\(\hat O = \hat M^{-1} \hat A\)</span>, <span class="math notranslate nohighlight">\(\hat B = \hat M\)</span> and
<span class="math notranslate nohighlight">\(\lambda = \mu\)</span>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">vector_view_t</span> <span class="o">=</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">vector_view_t</span><span class="p">;</span>
<span class="k">using</span> <span class="n">vector_const_view_t</span> <span class="o">=</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">vector_const_view_t</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">op</span> <span class="o">=</span> <span class="p">[](</span><span class="n">vector_view_t</span> <span class="n">in</span><span class="p">,</span> <span class="n">vector_view_t</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Code implementing action of matrices M^{-1} and A according to</span>
  <span class="c1">//</span>
  <span class="c1">// in = A * in</span>
  <span class="c1">// out = M^{-1} * in</span>
  <span class="c1">//</span>
  <span class="c1">// Note that unlike in the other computational modes, both &#39;in&#39; and</span>
  <span class="c1">// &#39;out&#39; must be updated!</span>
<span class="p">};</span>
<span class="k">auto</span> <span class="n">Bop</span> <span class="o">=</span> <span class="p">[](</span><span class="n">vector_const_view_t</span> <span class="n">in</span><span class="p">,</span> <span class="n">vector_view_t</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Code implementing action of matrix M on vector &#39;in&#39;:</span>
  <span class="c1">// out = M * in</span>
<span class="p">};</span>

<span class="n">solver</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Bop</span><span class="p">,</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">Inverse</span><span class="p">,</span> <span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>Inverting a sparse matrix <span class="math notranslate nohighlight">\(\hat M\)</span> will likely make it dense, which
is usually undesirable from the storage standpoint. A more practical
solution is to compute the sparse LU or Cholesky factorization of
<span class="math notranslate nohighlight">\(\hat M\)</span> once (outside of the lambda-functionâs body), and write
the lambda-function so that it (1) sets <code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">in</span></code> and (2) computes
<code class="docutils literal notranslate"><span class="pre">out</span></code> as the solution of the linear system <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">*</span> <span class="pre">out</span> <span class="pre">=</span> <span class="pre">in</span></code> using the
precomputed factorization.</p>
</li>
<li id="sym-shiftandinvert"><p><strong>Shift-and-Invert mode</strong> (for symmetric positive semi-definite
<span class="math notranslate nohighlight">\(\hat M\)</span>).</p>
<p>In this mode, the transformed eigenproblem is defined by
<span class="math notranslate nohighlight">\(\hat O = (\hat A -\sigma \hat M)^{-1} \hat M\)</span>,
<span class="math notranslate nohighlight">\(\hat B = \hat M\)</span> and <span class="math notranslate nohighlight">\(\lambda = 1/\mu + \sigma\)</span>.
The real spectral shift <span class="math notranslate nohighlight">\(\sigma\)</span> must be set in the parameters
structure, see the <a class="reference internal" href="#sym-sigma"><span class="std std-ref">list of parameters</span></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">vector_view_t</span> <span class="o">=</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">vector_view_t</span><span class="p">;</span>
<span class="k">using</span> <span class="n">vector_const_view_t</span> <span class="o">=</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">vector_const_view_t</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">op</span> <span class="o">=</span> <span class="p">[](</span><span class="n">vector_view_t</span> <span class="n">in</span><span class="p">,</span> <span class="n">vector_view_t</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Code implementing action of matrix (A - sigma*M)^{-1} * M on &#39;in&#39;:</span>
  <span class="c1">// out = (A - sigma*M)^{-1} * M * in</span>
<span class="p">};</span>
<span class="k">auto</span> <span class="n">Bop</span> <span class="o">=</span> <span class="p">[](</span><span class="n">vector_const_view_t</span> <span class="n">in</span><span class="p">,</span> <span class="n">vector_view_t</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Code implementing action of matrix M on vector &#39;in&#39;:</span>
  <span class="c1">// out = M * in</span>
<span class="p">};</span>

<span class="n">solver</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Bop</span><span class="p">,</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">ShiftAndInvert</span><span class="p">,</span> <span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>Inverting a sparse matrix <span class="math notranslate nohighlight">\(\hat A - \sigma\hat M\)</span> will likely make it
dense, which is usually undesirable from the storage standpoint. A more
practical solution is to compute the sparse LU or Cholesky factorization of
<span class="math notranslate nohighlight">\(\hat A - \sigma\hat M\)</span> once (outside of the lambda-functionâs body),
and write the lambda-function so that it (1) computes <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">*</span> <span class="pre">in</span></code> and
(2) computes <code class="docutils literal notranslate"><span class="pre">out</span></code> as the solution of the linear system
<code class="docutils literal notranslate"><span class="pre">(A</span> <span class="pre">-</span> <span class="pre">\sigma</span> <span class="pre">M)</span> <span class="pre">*</span> <span class="pre">out</span> <span class="pre">=</span> <span class="pre">M</span> <span class="pre">*</span> <span class="pre">in</span></code> using the precomputed factorization.</p>
</li>
<li id="sym-buckling"><p><strong>Buckling mode</strong> (for symmetric positive semi-definite
<span class="math notranslate nohighlight">\(\hat A\)</span> and symmetric indefinite <span class="math notranslate nohighlight">\(\hat M\)</span>).</p>
<p>In this mode, the transformed eigenproblem is defined by
<span class="math notranslate nohighlight">\(\hat O = (\hat A -\sigma \hat M)^{-1} \hat A\)</span>,
<span class="math notranslate nohighlight">\(\hat B = \hat A\)</span>, and <span class="math notranslate nohighlight">\(\lambda = \sigma \frac{\mu}{\mu-1}\)</span>.
The real spectral shift <span class="math notranslate nohighlight">\(\sigma\)</span> must be set in the parameters
structure, see the <a class="reference internal" href="#sym-sigma"><span class="std std-ref">list of parameters</span></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">vector_view_t</span> <span class="o">=</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">vector_view_t</span><span class="p">;</span>
<span class="k">using</span> <span class="n">vector_const_view_t</span> <span class="o">=</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">vector_const_view_t</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">op</span> <span class="o">=</span> <span class="p">[](</span><span class="n">vector_view_t</span> <span class="n">in</span><span class="p">,</span> <span class="n">vector_view_t</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Code implementing action of matrix</span>
  <span class="c1">// (A - sigma*M)^{-1} * A on &#39;in&#39;:</span>
  <span class="c1">// out = (A - sigma*M)^{-1} A * in</span>
<span class="p">};</span>
<span class="k">auto</span> <span class="n">Bop</span> <span class="o">=</span> <span class="p">[](</span><span class="n">vector_const_view_t</span> <span class="n">in</span><span class="p">,</span> <span class="n">vector_view_t</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Code implementing action of matrix A on vector &#39;in&#39;:</span>
  <span class="c1">// out = A * in</span>
<span class="p">};</span>

<span class="n">solver</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Bop</span><span class="p">,</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">Buckling</span><span class="p">,</span> <span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>Inverting a sparse matrix <span class="math notranslate nohighlight">\(\hat A - \sigma\hat M\)</span> will likely make it
dense, which is usually undesirable from the storage standpoint. A more
practical solution is to compute the sparse LU or Cholesky factorization of
<span class="math notranslate nohighlight">\(\hat A - \sigma\hat M\)</span> once (outside of the lambda-functionâs body),
and write the lambda-function so that it (1) computes
<code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">in</span></code> and (2) computes <code class="docutils literal notranslate"><span class="pre">out</span></code> as the solution of the linear
system <code class="docutils literal notranslate"><span class="pre">(A</span> <span class="pre">-</span> <span class="pre">\sigma</span> <span class="pre">M)</span> <span class="pre">*</span> <span class="pre">out</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">in</span></code> using the precomputed
factorization.</p>
</li>
<li id="sym-cayley"><p><strong>Cayley mode</strong> (for symmetric positive semi-definite
<span class="math notranslate nohighlight">\(\hat M\)</span>).</p>
<p>In this mode, the transformed eigenproblem is defined by
<span class="math notranslate nohighlight">\(\hat O = (\hat A -\sigma \hat M)^{-1} (\hat A + \sigma \hat M)\)</span>,
<span class="math notranslate nohighlight">\(\hat B = \hat M\)</span> and
<span class="math notranslate nohighlight">\(\lambda = \sigma\left(\frac{1+\mu}{1-\mu}\right)\)</span>.
The real spectral shift <span class="math notranslate nohighlight">\(\sigma\)</span> must be set in the parameters
structure, see the <a class="reference internal" href="#sym-sigma"><span class="std std-ref">list of parameters</span></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">vector_view_t</span> <span class="o">=</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">vector_view_t</span><span class="p">;</span>
<span class="k">using</span> <span class="n">vector_const_view_t</span> <span class="o">=</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">vector_const_view_t</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">op</span> <span class="o">=</span> <span class="p">[](</span><span class="n">vector_view_t</span> <span class="n">in</span><span class="p">,</span> <span class="n">vector_view_t</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Code implementing action of matrix</span>
  <span class="c1">// (A - sigma*M)^{-1} * (A + sigma*M) on &#39;in&#39;:</span>
  <span class="c1">// out = (A - sigma*M)^{-1} * (A + sigma*M) * in</span>
<span class="p">};</span>
<span class="k">auto</span> <span class="n">Bop</span> <span class="o">=</span> <span class="p">[](</span><span class="n">vector_const_view_t</span> <span class="n">in</span><span class="p">,</span> <span class="n">vector_view_t</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Code implementing action of matrix M on vector &#39;in&#39;:</span>
  <span class="c1">// out = M * in</span>
<span class="p">};</span>

<span class="n">solver</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Bop</span><span class="p">,</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">Cayley</span><span class="p">,</span> <span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>Inverting a sparse matrix <span class="math notranslate nohighlight">\(\hat A - \sigma\hat M\)</span> will likely make it
dense, which is usually undesirable from the storage standpoint. A more
practical solution is to compute the sparse LU or Cholesky factorization of
<span class="math notranslate nohighlight">\(\hat A - \sigma\hat M\)</span> once (outside of the lambda-functionâs body),
and write the lambda-function so that it (1) computes
<code class="docutils literal notranslate"><span class="pre">(A</span> <span class="pre">+</span> <span class="pre">\sigma</span> <span class="pre">M)</span> <span class="pre">*</span> <span class="pre">in</span></code> and (2) computes <code class="docutils literal notranslate"><span class="pre">out</span></code> as the solution of the
linear system <code class="docutils literal notranslate"><span class="pre">(A</span> <span class="pre">-</span> <span class="pre">\sigma</span> <span class="pre">M)</span> <span class="pre">*</span> <span class="pre">out</span> <span class="pre">=</span> <span class="pre">(A</span> <span class="pre">+</span> <span class="pre">\sigma</span> <span class="pre">M)</span> <span class="pre">*</span> <span class="pre">in</span></code> using the
precomputed factorization.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In most computational modes above, it is seemingly necessary to apply
operator <span class="math notranslate nohighlight">\(\hat B\)</span> to the same vector twice per generated Lanczos
vector, once in functor <code class="docutils literal notranslate"><span class="pre">op</span></code> and once in <code class="docutils literal notranslate"><span class="pre">Bop</span></code>. It is actually possible
to spare one of the applications. Calling <code class="docutils literal notranslate"><span class="pre">solver.Bx_available()</span></code> inside
<code class="docutils literal notranslate"><span class="pre">op</span></code> will tell whether <code class="docutils literal notranslate"><span class="pre">Bop</span></code> has already been called at the current
iteration, and <code class="docutils literal notranslate"><span class="pre">solver.Bx_vector()</span></code> will return a constant view of the
application result <span class="math notranslate nohighlight">\(\hat B \mathbf{x}\)</span>.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">out</span></code> views passed to the callable objects always expose one
of three length-<span class="math notranslate nohighlight">\(N\)</span> vectors stored inside the solver object. There is
another, indirect way to access them.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get index (0-2) of the current &#39;in&#39; vector and request a view of it</span>
<span class="k">auto</span> <span class="n">in_view</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">workspace_vector</span><span class="p">(</span><span class="n">solver</span><span class="p">.</span><span class="n">in_vector_n</span><span class="p">());</span>
<span class="c1">// Similar for the &#39;out&#39; vector</span>
<span class="k">auto</span> <span class="n">out_view</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">workspace_vector</span><span class="p">(</span><span class="n">solver</span><span class="p">.</span><span class="n">out_vector_n</span><span class="p">());</span>
</pre></div>
</div>
<p>In advanced usage scenarios, the implicit restarting procedure can be
customized via an extra argument of <code class="docutils literal notranslate"><span class="pre">solver</span></code>âs call operator.
See â<a class="reference internal" href="implicit_restarting.html#restarting"><span class="std std-ref">Advanced: Customization of Lanczos/Arnoldi implicit restarting</span></a>â for more details.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">shifts_f</span> <span class="o">=</span> <span class="p">[](</span><span class="n">solver_t</span><span class="o">::</span><span class="n">real_vector_const_view_t</span> <span class="n">ritz_values</span><span class="p">,</span>
                   <span class="n">solver_t</span><span class="o">::</span><span class="n">real_vector_const_view_t</span> <span class="n">ritz_bounds</span><span class="p">,</span>
                   <span class="n">solver_t</span><span class="o">::</span><span class="n">real_vector_view_t</span> <span class="n">shifts</span><span class="p">)</span> <span class="p">{</span>
                     <span class="c1">// Compute shifts for the implicit restarting</span>
                   <span class="p">};</span>

<span class="c1">// Standard mode</span>
<span class="n">solver</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">shifts_f</span><span class="p">);</span>
<span class="c1">// Other modes, e.g. Inverse</span>
<span class="n">solver</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Bop</span><span class="p">,</span> <span class="n">solver_t</span><span class="o">::</span><span class="n">Inverse</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">shifts_f</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">solver_t::operator()</span></code> can throw two special exception types.</p>
<ul class="simple">
<li><p><a class="reference internal" href="../reference/solver_base.html#maxiter-reached"><span class="std std-ref">ezarpack::maxiter_reached</span></a> - Maximum number of
implicitly restarted Lanczos iterations has been reached.</p></li>
<li><p><a class="reference internal" href="../reference/solver_base.html#ncv-insufficient"><span class="std std-ref">ezarpack::ncv_insufficient</span></a> - No shifts could be
applied during a cycle of the Implicitly restarted Lanczos iteration.
Consider increasing the number of Lanczos vectors generated at each
iteration (<a class="reference internal" href="#sym-ncv"><span class="std std-ref">ncv</span></a> parameter).</p></li>
</ul>
<p>The rest of possible problems reported by ARPACK-NG result in generic
<a class="reference external" href="https://en.cppreference.com/w/cpp/error/runtime_error">std::runtime_error</a>
exceptions.</p>
</li>
<li><p>Request computed eigenvalues and eigenvectors (provided the
<a class="reference internal" href="#sym-compute-eigenvectors"><span class="std std-ref">compute_eigenvectors</span></a> parameter has been
enabled).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">lambda</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">eigenvalues</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">vecs</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">eigenvectors</span><span class="p">();</span>
</pre></div>
</div>
<p>The eigenvectors are columns of the real matrix view <code class="docutils literal notranslate"><span class="pre">vecs</span></code>.
If the diagonalization run has ended prematurely (for example, when
the maximum number of iterations has been reached), then it is still
possible to extract <code class="docutils literal notranslate"><span class="pre">solver.nconv()</span></code> converged eigenpairs.</p>
</li>
<li><p>Optionally request statistics about the completed run.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Print some computation statistics</span>
<span class="k">auto</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">stats</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Number of Lanczos update iterations: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">stats</span><span class="p">.</span><span class="n">n_iter</span>
          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Total number of O*x operations: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">stats</span><span class="p">.</span><span class="n">n_op_x_operations</span>
          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Total number of B*x operations: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">stats</span><span class="p">.</span><span class="n">n_b_x_operations</span>
          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Total number of steps of re-orthogonalization: &quot;</span>
          <span class="o">&lt;&lt;</span> <span class="n">stats</span><span class="p">.</span><span class="n">n_reorth_steps</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ol>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="choice.html"
                        title="previous chapter">What algorithm variant is right for your problem?</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="asymmetric.html"
                        title="next chapter">General real eigenproblems</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/guide/symmetric.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="asymmetric.html" title="General real eigenproblems"
             >next</a> |</li>
        <li class="right" >
          <a href="choice.html" title="What algorithm variant is right for your problem?"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">ezARPACK 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >User guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Symmetric real eigenproblems</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Igor Krivenko.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.3.1.
    </div>
  </body>
</html>