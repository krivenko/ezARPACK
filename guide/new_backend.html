
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced: Adding a new storage backend &#8212; ezARPACK 0.9 documentation</title>
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="/ezARPACK/mathjax/MathJax.js?config=default"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Usage examples" href="examples.html" />
    <link rel="prev" title="Advanced: Customization of Lanczos/Arnoldi implicit restarting" href="implicit_restarting.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="examples.html" title="Usage examples"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="implicit_restarting.html" title="Advanced: Customization of Lanczos/Arnoldi implicit restarting"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">ezARPACK 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">User guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Advanced: Adding a new storage backend</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="advanced-adding-a-new-storage-backend">
<span id="new-backend"></span><h1>Advanced: Adding a new storage backend<a class="headerlink" href="#advanced-adding-a-new-storage-backend" title="Permalink to this headline">¶</a></h1>
<p>ezARPACK offers support for a few numerical linear algebra frameworks
<a class="reference internal" href="backends.html#backends"><span class="std std-ref">out of the box</span></a>. Thanks to the decoupled design of ezARPACK’s
solver classes, it is fairly easy to extend the support to other matrix/vector
algebra libraries. In order to be conceptually compatible with ezARPACK’s
architecture, a C++ library has to implement the following abstractions.</p>
<ul class="simple">
<li><p>A class that wraps a one-dimensional contiguous array of <code class="docutils literal notranslate"><span class="pre">double</span></code> elements
(<em>real vector type</em>).</p></li>
<li><p>A class that wraps a one-dimensional contiguous array of
<code class="docutils literal notranslate"><span class="pre">std::complex&lt;double&gt;</span></code> elements (<em>complex vector type</em>).</p></li>
<li><p>A class that wraps a one-dimensional contiguous array of <code class="docutils literal notranslate"><span class="pre">int</span></code> elements
(<em>integer vector type</em>).</p></li>
<li><p>A class that wraps a two-dimensional
<a class="reference external" href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">column-major</a>
contiguous array of <code class="docutils literal notranslate"><span class="pre">double</span></code> elements (<em>real matrix type</em>).</p></li>
<li><p>A class that wraps a two-dimensional
<a class="reference external" href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">column-major</a>
contiguous array of <code class="docutils literal notranslate"><span class="pre">std::complex&lt;double&gt;</span></code> elements (<em>complex matrix type</em>).</p></li>
<li><p>A class that implements a partial contiguous view of a real/complex vector,
i.e. a subvector.</p></li>
<li><p>A class that implements a rectangular contiguous view of a real/complex
matrix, i.e. a matrix block. It is sufficient to support only the blocks
including all matrix rows and a number of the leftmost columns.</p></li>
<li><p>All vector and matrix types are subject to two additional requirements,</p>
<ul>
<li><p>Their underlying data arrays must be resizable at run time;</p></li>
<li><p>There must be a way to acquire a pointer to the underlying data array.</p></li>
</ul>
</li>
</ul>
<p>Let us say one has a fictitious library <code class="docutils literal notranslate"><span class="pre">mylib</span></code> that meets all listed
requirements. One lets ezARPACK know about the new library by implementing a
<em>storage backend</em> in a new header file. In the following sections,
we give step-by-step instructions on how to write such a header.</p>
<p>For a complete example of a storage backend implementation, see
<code class="docutils literal notranslate"><span class="pre">&lt;ezarpack/storages/eigen.hpp&gt;</span></code> (<a class="reference internal" href="../reference/storages/eigen.html#refeigen"><span class="std std-ref">Eigen 3</span></a> backend).</p>
<div class="section" id="basic-header-structure">
<h2>Basic header structure<a class="headerlink" href="#basic-header-structure" title="Permalink to this headline">¶</a></h2>
<p>Our storage backend header must include <code class="docutils literal notranslate"><span class="pre">&lt;complex&gt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;ezarpack/storages/base.hpp&gt;</span></code> and all relevant headers of <code class="docutils literal notranslate"><span class="pre">mylib</span></code>.
Normally, it is a good idea to also use some include guard macros of
<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">once</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// mylib_storage.hpp - Storage backend for mylib.</span>

<span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;complex&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ezarpack/storages/base.hpp&gt;</span><span class="cp"></span>

<span class="c1">// Include all relevant parts of &#39;mylib&#39;.</span>
<span class="cp">#include</span> <span class="cpf">&lt;mylib.hpp&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>Every storage backend must define a tag type associated with it. The actual type
does not really matter, so it can be an empty structure.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// mylib storage backend tag.</span>
<span class="k">struct</span> <span class="n">mylib_storage</span> <span class="p">{};</span>
</pre></div>
</div>
<p>Passing the defined tag type as the second template parameter to
<code class="docutils literal notranslate"><span class="pre">arpack_solver</span></code> (e.g. <a class="reference internal" href="../reference/solver_symmetric.html#refsolversymmetric"><span class="std std-ref">arpack_solver&lt;Symmetric,mylib_storage&gt;</span></a>) will enable use of the <code class="docutils literal notranslate"><span class="pre">mylib</span></code> backend in the solver.</p>
<p>The most crucial and biggest part of the header is a specialization of the
<code class="docutils literal notranslate"><span class="pre">storage_traits</span></code> structure. This traits structure is going to be a ‘glue’
layer between <a class="reference internal" href="../reference/solver_base.html#refsolverbase"><span class="std std-ref">arpack_solver</span></a> and the new library.
<code class="docutils literal notranslate"><span class="pre">arpack_solver</span></code> extracts <code class="docutils literal notranslate"><span class="pre">mylib</span></code>-specific type
information from typedef members of <code class="docutils literal notranslate"><span class="pre">storage_traits</span></code> and calls its static
member functions to handle <code class="docutils literal notranslate"><span class="pre">mylib</span></code>’s vector/matrix/view objects.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">storage_traits</span><span class="o">&lt;</span><span class="n">mylib_storage</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// Member typedefs.</span>
  <span class="p">...</span>
  <span class="c1">// Static members functions.</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The rest of this HOWTO gives a detailed description of mandatory and optional
members of the <code class="docutils literal notranslate"><span class="pre">storage_traits</span></code> specialization.</p>
</div>
<div class="section" id="member-type-definitions-of-the-traits-structure">
<h2>Member type definitions of the traits structure<a class="headerlink" href="#member-type-definitions-of-the-traits-structure" title="Permalink to this headline">¶</a></h2>
<p>The member type definitions of <code class="docutils literal notranslate"><span class="pre">storage_traits</span></code> form two groups. The first one
is for the container (vector/matrix) types.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// One-dimensional wrapper around a contiguous array of &#39;double&#39;</span>
<span class="k">using</span> <span class="n">real_vector_type</span> <span class="o">=</span> <span class="n">mylib</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// One-dimensional wrapper around a contiguous array of</span>
<span class="c1">// &#39;std::complex&lt;double&gt;&#39;.</span>
<span class="k">using</span> <span class="n">complex_vector_type</span> <span class="o">=</span> <span class="n">mylib</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="c1">// One-dimensional wrapper around a contiguous array of &#39;int&#39;.</span>
<span class="k">using</span> <span class="n">int_vector_type</span> <span class="o">=</span> <span class="n">mylib</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Two-dimensional wrapper around a contiguous array of &#39;double&#39;.</span>
<span class="c1">// The storage order must be column-major.</span>
<span class="k">using</span> <span class="n">real_matrix_type</span> <span class="o">=</span> <span class="n">mylib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Two-dimensional wrapper around a contiguous array of</span>
<span class="c1">// &#39;std::complex&lt;double&gt;&#39;. The storage order must be column-major.</span>
<span class="k">using</span> <span class="n">complex_matrix_type</span> <span class="o">=</span> <span class="n">mylib</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>The second group includes all <em>view</em> type declarations. ezARPACK makes a
distinction between constant views and regular (read/write) views. The constant
views are returned/passed to the user code whenever a data array is meant to be
read and should be protected against external modifications. Although not
recommended, it is still possible to use <code class="docutils literal notranslate"><span class="pre">mylib</span></code>’s read/write views as a
substitute for the constant views. This will result in functional albeit more
error-prone user code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Contiguous partial view of a real vector (subvector).</span>
<span class="k">using</span> <span class="n">real_vector_view_type</span> <span class="o">=</span> <span class="n">mylib</span><span class="o">::</span><span class="n">vector_view</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Contiguous partial constant view of a real vector (subvector).</span>
<span class="k">using</span> <span class="n">real_vector_const_view_type</span> <span class="o">=</span> <span class="n">mylib</span><span class="o">::</span><span class="n">vector_cview</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Contiguous partial view of a complex vector (subvector).</span>
<span class="k">using</span> <span class="n">complex_vector_view_type</span> <span class="o">=</span> <span class="n">mylib</span><span class="o">::</span><span class="n">vector_view</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="c1">// Contiguous partial constant view of a complex vector (subvector).</span>
<span class="k">using</span> <span class="n">complex_vector_const_view_type</span> <span class="o">=</span>
  <span class="n">mylib</span><span class="o">::</span><span class="n">vector_cview</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="c1">// Contiguous partial constant view of a real matrix (matrix block) that</span>
<span class="c1">// includes a number of the leftmost columns.</span>
<span class="k">using</span> <span class="n">real_matrix_const_view_type</span> <span class="o">=</span> <span class="n">mylib</span><span class="o">::</span><span class="n">matrix_cview</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Contiguous partial constant view of a complex matrix (matrix block) that</span>
<span class="c1">// includes a number of the leftmost columns.</span>
<span class="k">using</span> <span class="n">complex_matrix_const_view_type</span> <span class="o">=</span>
  <span class="n">mylib</span><span class="o">::</span><span class="n">matrix_cview</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="static-member-functions-of-the-traits-structure">
<h2>Static member functions of the traits structure<a class="headerlink" href="#static-member-functions-of-the-traits-structure" title="Permalink to this headline">¶</a></h2>
<p>The following member functions are mandatory for any specialization of
<code class="docutils literal notranslate"><span class="pre">storage_traits</span></code>.</p>
<ul>
<li><p>Vector object factories.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Make a real vector of a given size.</span>
<span class="k">static</span> <span class="n">real_vector_type</span> <span class="nf">make_real_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call real_vector_type&#39;s constructor and return the result.</span>
<span class="p">}</span>
<span class="c1">// Make a complex vector of a given size.</span>
<span class="k">static</span> <span class="n">complex_vector_type</span> <span class="nf">make_complex_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call complex_vector_type&#39;s constructor and return the result.</span>
<span class="p">}</span>
<span class="c1">// Make an integer vector of a given size.</span>
<span class="k">static</span> <span class="n">int_vector_type</span> <span class="nf">make_int_vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call int_vector_type&#39;s constructor and return the result.</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Matrix object factories.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Make a real matrix with given dimensions.</span>
<span class="k">static</span> <span class="n">real_matrix_type</span> <span class="nf">make_real_matrix</span><span class="p">(</span><span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call real_matrix_type&#39;s constructor and return the result.</span>
<span class="p">}</span>
<span class="c1">// Make a complex matrix with given dimensions.</span>
<span class="k">static</span> <span class="n">complex_matrix_type</span> <span class="nf">make_complex_matrix</span><span class="p">(</span><span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call complex_matrix_type&#39;s constructor and return the result.</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Vector/matrix destructors.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Free memory occupied by vector &#39;v&#39;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">real_vector_type</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">complex_vector_type</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">int_vector_type</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="c1">// Free memory occupied by matrix &#39;m&#39;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">real_matrix_type</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">complex_matrix_type</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">destroy()</span></code> functions should free memory occupied by
<code class="docutils literal notranslate"><span class="pre">v</span></code> and <code class="docutils literal notranslate"><span class="pre">m</span></code> <strong>if and only if</strong> it is not already done by
<code class="docutils literal notranslate"><span class="pre">v</span></code>’s and <code class="docutils literal notranslate"><span class="pre">m</span></code>’s destructors. Since most libraries manage the memory on
their own, bodies of <code class="docutils literal notranslate"><span class="pre">destroy()</span></code> should normally be left blank.</p>
</div>
</li>
<li><p>Resize functions.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Resize vector &#39;v&#39;.</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="n">real_vector_type</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_size</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="n">complex_vector_type</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_size</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="n">int_vector_type</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_size</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="c1">// Resize matrix &#39;m&#39;.</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="n">real_matrix_type</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_cols</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="n">complex_matrix_type</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_cols</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Raw memory pointer accessors.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Return a pointer to the underlying data array owned by vector &#39;v&#39;.</span>
<span class="k">static</span> <span class="kt">double</span><span class="o">*</span> <span class="nf">get_data_ptr</span><span class="p">(</span><span class="n">real_vector_type</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">get_data_ptr</span><span class="p">(</span><span class="n">complex_vector_type</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span><span class="o">*</span> <span class="n">get_data_ptr</span><span class="p">(</span><span class="n">int_vector_type</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="c1">// Return a pointer to the underlying data array owned by matrix &#39;m&#39;.</span>
<span class="k">static</span> <span class="kt">double</span><span class="o">*</span> <span class="n">get_data_ptr</span><span class="p">(</span><span class="n">real_matrix_type</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">get_data_ptr</span><span class="p">(</span><span class="n">complex_matrix_type</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Vector view factories.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Make a complete view of vector &#39;v&#39;.</span>
<span class="k">static</span> <span class="n">real_vector_view_type</span> <span class="nf">make_vector_view</span><span class="p">(</span><span class="n">real_vector_type</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call real_vector_view_type&#39;s constructor and return the result.</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">complex_vector_view_type</span> <span class="nf">make_vector_view</span><span class="p">(</span><span class="n">complex_vector_type</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call complex_vector_view_type&#39;s constructor and return the result.</span>
<span class="p">}</span>

<span class="c1">// Make a partial view of vector &#39;v&#39; starting at position &#39;start&#39; and</span>
<span class="c1">// including &#39;size&#39; elements.</span>
<span class="k">static</span> <span class="n">real_vector_view_type</span>
<span class="nf">make_vector_view</span><span class="p">(</span><span class="n">real_vector_type</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call real_vector_view_type&#39;s constructor and return the result.</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">complex_vector_view_type</span>
<span class="nf">make_vector_view</span><span class="p">(</span><span class="n">complex_vector_type</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call complex_vector_view_type&#39;s constructor and return the result.</span>
<span class="p">}</span>

<span class="c1">// Make a constant partial view of vector &#39;v&#39; starting at position &#39;start&#39;</span>
<span class="c1">// and including &#39;size&#39; elements.</span>
<span class="k">static</span> <span class="n">real_vector_const_view_type</span>
<span class="nf">make_vector_const_view</span><span class="p">(</span><span class="n">real_vector_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call real_vector_const_view_type&#39;s constructor and return the result.</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">complex_vector_const_view_type</span>
<span class="nf">make_vector_const_view</span><span class="p">(</span><span class="n">complex_vector_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call complex_vector_const_view_type&#39;s constructor and return the result</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Matrix constant view factories.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Make a complete constant view of matrix &#39;m&#39;.</span>
<span class="k">static</span> <span class="n">real_matrix_const_view_type</span>
<span class="nf">make_matrix_const_view</span><span class="p">(</span><span class="n">real_matrix_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call real_matrix_const_view_type&#39;s constructor and return the result.</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">complex_matrix_const_view_type</span>
<span class="nf">make_matrix_const_view</span><span class="p">(</span><span class="n">complex_matrix_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call complex_matrix_const_view_type&#39;s constructor and return the result</span>
<span class="p">}</span>

<span class="c1">// Make a partial constant view of matrix &#39;m&#39; including &#39;cols&#39;</span>
<span class="c1">// leftmost columns.</span>
<span class="k">static</span> <span class="n">real_matrix_const_view_type</span>
<span class="nf">make_matrix_const_view</span><span class="p">(</span><span class="n">real_matrix_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call real_matrix_const_view_type&#39;s constructor and return the result.</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">complex_matrix_const_view_type</span>
<span class="nf">make_matrix_const_view</span><span class="p">(</span><span class="n">complex_matrix_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call complex_matrix_const_view_type&#39;s constructor and return the result</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Some of the functions, such as <code class="docutils literal notranslate"><span class="pre">destroy()</span></code> and <code class="docutils literal notranslate"><span class="pre">resize()</span></code>, do not have to be
defined separately for each argument type. It is acceptable to use function
templates instead.</p>
<p>With these functions implemented, one can already instantiate and use
<a class="reference internal" href="../reference/solver_symmetric.html#refsolversymmetric"><span class="std std-ref">arpack_solver&lt;Symmetric,mylib_storage&gt;</span></a> and
<a class="reference internal" href="../reference/solver_complex.html#refsolvercomplex"><span class="std std-ref">arpack_solver&lt;Complex,mylib_storage&gt;</span></a>. The asymmetric case, however, requires more work, as
described in the next section.</p>
</div>
<div class="section" id="optional-eigenvalue-eigenvector-post-processing-functions">
<h2>Optional: Eigenvalue/eigenvector post-processing functions<a class="headerlink" href="#optional-eigenvalue-eigenvector-post-processing-functions" title="Permalink to this headline">¶</a></h2>
<p>Because of specifics of the internal data storage format and numerical
algorithm, extracting eigenvalues and eigenvectors after a completed
<a class="reference internal" href="../reference/solver_asymmetric.html#refsolverasymmetric"><span class="std std-ref">arpack_solver&lt;Asymmetric,mylib_storage&gt;</span></a> run needs
some post-processing that is not done by ARPACK-NG itself.
The storage traits structure may optionally implement three static
member functions, which will be called by the asymmetric solver to extract a
computed eigensystem from memory buffers and return it to the user in
a convenient form.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">complex_vector_type</span>
<span class="nf">make_asymm_eigenvalues</span><span class="p">(</span><span class="n">real_vector_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">dr</span><span class="p">,</span>
                       <span class="n">real_vector_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">di</span><span class="p">,</span>
                       <span class="kt">int</span> <span class="n">nconv</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Compute and return dr + i*di</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">make_asymm_eigenvalues()</span></code> is the simplest of the three functions. It is
called to combine two real vectors – lists of real (<code class="docutils literal notranslate"><span class="pre">dr</span></code>) and
imaginary (<code class="docutils literal notranslate"><span class="pre">di</span></code>) parts of computed eigenvalues – into one complex vector.
<code class="docutils literal notranslate"><span class="pre">nconv</span></code> is the total number of the computed eigenvalues. Exactly <code class="docutils literal notranslate"><span class="pre">nconv</span></code>
first elements of <code class="docutils literal notranslate"><span class="pre">dr</span></code> and <code class="docutils literal notranslate"><span class="pre">di</span></code> must be used to form the complex vector
(<code class="docutils literal notranslate"><span class="pre">dr</span></code> and <code class="docutils literal notranslate"><span class="pre">di</span></code> can, in general, be longer or not providing size information
at all).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="k">static</span> <span class="n">complex_matrix_type</span>
<span class="nf">make_asymm_eigenvectors</span><span class="p">(</span><span class="n">real_vector_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">z</span><span class="p">,</span>
                        <span class="n">real_vector_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">di</span><span class="p">,</span>
                        <span class="kt">int</span> <span class="n">N</span><span class="p">,</span>
                        <span class="kt">int</span> <span class="n">nconv</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Extract and return eigenvectors as columns of a complex matrix.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function extracts eigenvectors from a real vector <code class="docutils literal notranslate"><span class="pre">z</span></code> according to
special rules. <code class="docutils literal notranslate"><span class="pre">z</span></code> holds components of the eigenvectors as a sequence of
<code class="docutils literal notranslate"><span class="pre">nconv</span></code> length-<code class="docutils literal notranslate"><span class="pre">N</span></code> chunks, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the dimension of the eigenproblem
and <code class="docutils literal notranslate"><span class="pre">nconv</span></code> has the same meaning as before. Meaning of each chunk depends on
the corresponding component of <code class="docutils literal notranslate"><span class="pre">di</span></code>. If <code class="docutils literal notranslate"><span class="pre">di[i]</span></code> is zero, then the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th
chunk of <code class="docutils literal notranslate"><span class="pre">z</span></code> contains a real eigenvector. Otherwise,
<code class="docutils literal notranslate"><span class="pre">di[i]</span> <span class="pre">=</span> <span class="pre">-di[i+1]</span> <span class="pre">!=</span> <span class="pre">0</span></code>, in which case the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th and <code class="docutils literal notranslate"><span class="pre">(i+1)</span></code>-th chunks
of <code class="docutils literal notranslate"><span class="pre">z</span></code> are real and imaginary parts of a complex eigenvector respectively.
Every such pair corresponds to a complex conjugate pair of eigenvectors,
so that the total amount of vectors stored in <code class="docutils literal notranslate"><span class="pre">z</span></code> is exactly <code class="docutils literal notranslate"><span class="pre">nconv</span></code>.
The extracted eigenvectors must be returned as columns of a complex
<code class="docutils literal notranslate"><span class="pre">N</span></code> x <code class="docutils literal notranslate"><span class="pre">nconv</span></code> matrix.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="k">static</span> <span class="n">complex_vector_type</span>
<span class="n">make_asymm_eigenvalues</span><span class="p">(</span><span class="n">real_vector_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">z</span><span class="p">,</span>
                      <span class="n">real_vector_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">di</span><span class="p">,</span>
                      <span class="n">A</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">,</span>
                      <span class="kt">int</span> <span class="n">N</span><span class="p">,</span>
                      <span class="kt">int</span> <span class="n">nconv</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Compute eigenvalues as Rayleigh quotients and return them in</span>
  <span class="c1">// a complex vector.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">ShiftAndInvertReal</span></code> and <code class="docutils literal notranslate"><span class="pre">ShiftAndInvertImag</span></code> spectral transformation
modes, ARPACK-NG computes eigenvalues of an auxiliary real matrix. Those
eigenvalues are implicitly related to the ones of the original eigenproblem.
One way to extract the original eigenvalues is via solution of a quadratic
equation. Unfortunately, this approach is not perfect, because solutions
of quadratic equations are not unique, and it can be difficult to match the
correct solution with a given eigenvector <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>. A robust
alternative approach is to compute the eigenvalue <span class="math notranslate nohighlight">\(\lambda\)</span> of
<span class="math notranslate nohighlight">\(\hat A\mathbf{x} = \lambda\hat M\mathbf{x}\)</span> as the Rayleigh quotient
<span class="math notranslate nohighlight">\(\lambda = \frac{\mathbf{x}^\dagger \hat A \mathbf{x}}
{\mathbf{x}^\dagger\hat M \mathbf{x}}\)</span>, which is the purpose of the last of the
three functions. <code class="docutils literal notranslate"><span class="pre">z</span></code>, <code class="docutils literal notranslate"><span class="pre">di</span></code>, <code class="docutils literal notranslate"><span class="pre">N</span></code> and <code class="docutils literal notranslate"><span class="pre">nconv</span></code> have the same meaning as
before, and callable object <code class="docutils literal notranslate"><span class="pre">a</span></code> represents the linear operator <span class="math notranslate nohighlight">\(\hat A\)</span>.
This overload of <code class="docutils literal notranslate"><span class="pre">make_asymm_eigenvalues()</span></code> should extract the eigenvectors
from <code class="docutils literal notranslate"><span class="pre">z</span></code> one by one and compute <span class="math notranslate nohighlight">\(\lambda\)</span> for each of them. It is
beneficial to treat the real vectors differently from the complex ones,
as the Rayleigh quotient can be computed at lower memory and CPU costs
if <span class="math notranslate nohighlight">\(\mathbf{x}^\dagger = \mathbf{x}^T\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Despite the name, the quotients amount to just the numerators.
ARPACK-NG guarantees that <span class="math notranslate nohighlight">\(\mathbf{x}^\dagger\hat M
\mathbf{x} = 1\)</span>, so there is no need to consider matrix
<span class="math notranslate nohighlight">\(\hat M\)</span> at all.</p>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Advanced: Adding a new storage backend</a><ul>
<li><a class="reference internal" href="#basic-header-structure">Basic header structure</a></li>
<li><a class="reference internal" href="#member-type-definitions-of-the-traits-structure">Member type definitions of the traits structure</a></li>
<li><a class="reference internal" href="#static-member-functions-of-the-traits-structure">Static member functions of the traits structure</a></li>
<li><a class="reference internal" href="#optional-eigenvalue-eigenvector-post-processing-functions">Optional: Eigenvalue/eigenvector post-processing functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="implicit_restarting.html"
                        title="previous chapter">Advanced: Customization of Lanczos/Arnoldi implicit restarting</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="examples.html"
                        title="next chapter">Usage examples</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/guide/new_backend.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="examples.html" title="Usage examples"
             >next</a> |</li>
        <li class="right" >
          <a href="implicit_restarting.html" title="Advanced: Customization of Lanczos/Arnoldi implicit restarting"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">ezARPACK 0.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >User guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Advanced: Adding a new storage backend</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Igor Krivenko.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
  </body>
</html>